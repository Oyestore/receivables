## 7. Architectural Design

This section outlines the architectural blueprint for the Invoice Generation Agent module, focusing on its structure, components, interactions, and non-functional requirements like modularity, multi-tenancy, and scalability.

### 7.1. Module Overview and Placement

The Invoice Generation Agent is a core, self-contained backend module within the SME Receivables Management Platform. Its primary responsibility encompasses the entire lifecycle of invoice creation, management, and processing, including AI-assisted data extraction, template application, and tax calculations.

*   **Responsibilities:** Smart invoice creation (manual, AI-assisted, recurring, duplication), template management, tax computation, product/service catalog integration, and client-specific defaults application.
*   **Interactions:**
    *   Exposes a set of RESTful APIs for consumption by the frontend client application.
    *   May interact with other future backend agents or services (e.g., a dedicated Notifications Agent, Analytics Agent) via internal APIs or message queues.
    *   Interacts with the shared PostgreSQL database, strictly enforcing tenant data isolation for all operations.
    *   Communicates with an AI service (internal or external) for OCR and data extraction from uploaded documents.

### 7.2. High-Level Components

The agent will be structured with a layered architecture:

1.  **API Layer (Controller Layer):**
    *   Built using Node.js with a framework like Express.js or NestJS (recommended for structure and scalability).
    *   Handles incoming HTTP requests, routing them to appropriate service layer methods.
    *   Manages request validation (data types, required fields, formats).
    *   Handles authentication and authorization (e.g., validating JWTs, ensuring user has permissions for the tenant and action). This might leverage a shared authentication module/middleware if available platform-wide.
    *   Formats API responses (success data, error messages).

2.  **Service Layer (Business Logic Layer):**
    *   Contains the core business logic and orchestrates operations for all features of the Invoice Generation Agent.
    *   Implements the functionalities defined in Sections 2 and 3 of this document.
    *   Coordinates interactions between internal sub-modules (Core Invoice Engine, Template Management, Tax Engine) and the Data Access Layer.
    *   Manages transactions and ensures data consistency.
    *   Interfaces with the AI Integration Service Client for OCR tasks.

3.  **Data Access Layer (DAL):**
    *   Abstracts all database interactions, providing a clear API for the Service Layer to perform CRUD (Create, Read, Update, Delete) operations.
    *   Will use an ORM (e.g., Sequelize for PostgreSQL) or a robust query builder to interact with the PostgreSQL database.
    *   Critically, all database queries performed by the DAL must enforce multi-tenancy by including `tenant_id` filters to ensure strict data isolation.
    *   Manages database connections and pooling.

4.  **AI Integration Service Client:**
    *   A dedicated component (e.g., a class or service) responsible for all communication with the external/internal AI OCR service.
    *   Handles formatting requests to the AI service (e.g., sending document data/streams) and parsing its responses (e.g., structured JSON output).
    *   Manages API keys, authentication, and error handling related to the AI service.

### 7.3. Internal Sub-modules (Logical Grouping within Service Layer)

These are not necessarily separate microservices initially but represent distinct areas of responsibility within the Invoice Generation Agent\'s service layer. They can be developed as well-defined classes or sets of functions.

1.  **Core Invoice Processing Engine:**
    *   Manages the lifecycle of invoices: creation (manual, AI-assisted from OCR data, duplication, recurring), validation, storage, retrieval, updates, and status changes (e.g., draft, sent, paid, void).
    *   Handles the logic for generating invoice numbers (tenant-specific sequences).
    *   Orchestrates the application of client defaults, product catalog items, and tax calculations during invoice creation/update.
    *   Manages bulk import of invoices from structured data (e.g., CSV).

2.  **Template Management Sub-module:**
    *   Manages CRUD operations for invoice templates, ensuring they are tenant-specific.
    *   Provides functionality to select and apply a template to an invoice.
    *   Handles the rendering of invoice data into a final presentable format (e.g., HTML for preview, PDF for download/sending). This may involve using a templating engine (e.g., Handlebars, EJS) and a PDF generation library (e.g., Puppeteer, pdf-lib).

3.  **Tax Engine Sub-module:**
    *   Manages tax configurations, rules, and rates, specific to each tenant, with a primary focus on the Indian GST system.
    *   Provides an interface to calculate applicable taxes for each line item and the overall invoice based on product/service type, client location, and tenant-specific tax rules.
    *   Ensures tax details are correctly structured for display on the invoice and for reporting.

### 7.4. Technology Stack (Confirmation)

*   **Backend Framework:** Node.js with NestJS (preferred for its modular architecture, TypeScript support, and scalability features) or Express.js.
*   **Database:** PostgreSQL.
*   **AI Service Communication:** HTTP/S API calls to the designated AI OCR service.
*   **PDF Generation:** A suitable Node.js library (e.g., Puppeteer for HTML-to-PDF, or a direct PDF manipulation library).
*   **Caching (Optional but Recommended for Scale):** Redis for caching frequently accessed, rarely changing data (e.g., tenant configurations, compiled templates).
*   **Job Queue (Optional but Recommended for Scale):** For handling asynchronous tasks like bulk imports or complex report generation (e.g., BullMQ with Redis).
*   **Deployment:** Dockerized containers orchestrated by Docker Compose (for initial setup) and designed for future deployment on platforms like Kubernetes for scalability.

### 7.5. Data Flow Examples

*(Detailed data flow diagrams would be part of a more in-depth design phase, but high-level flows are described here.)*

1.  **AI-Assisted Invoice Creation:**
    *   User uploads a document (PDF/image) via the frontend.
    *   Frontend sends the file to the Invoice Agent\'s API Layer (`POST /api/invoices/upload-for-ocr`).
    *   API Layer authenticates, validates, and passes the file to the Service Layer.
    *   Service Layer invokes the AI Integration Service Client.
    *   AI Client sends the document to the AI OCR Service.
    *   AI OCR Service processes the document and returns structured data (JSON).
    *   AI Client parses the response and returns it to the Service Layer.
    *   Service Layer uses the structured data to pre-fill a new invoice object (draft status) and returns this to the API Layer, then to the frontend.
    *   User reviews, modifies, and completes the invoice details on the frontend.
    *   User submits the completed invoice data (`POST /api/invoices`).
    *   API Layer validates and passes to Service Layer.
    *   Service Layer (Core Invoice Engine) finalizes validation, applies business rules (e.g., client defaults, product lookups), invokes Tax Engine, and then instructs DAL to save the invoice to the database.

2.  **Generating a PDF Invoice for an Existing Record:**
    *   User requests to view/download a PDF for an existing invoice via frontend (`GET /api/invoices/{invoice_id}/pdf`).
    *   API Layer validates request and retrieves `invoice_id`.
    *   Service Layer retrieves full invoice data (including line items, client details) via DAL.
    *   Service Layer retrieves the appropriate invoice template (via Template Management Sub-module).
    *   Service Layer ensures tax calculations are up-to-date (or re-calculates if necessary via Tax Engine).
    *   Template Management Sub-module renders the invoice data using the chosen template into a PDF format.
    *   The generated PDF is streamed back to the user via the API Layer.

### 7.6. Scalability, Modularity, and Multi-tenancy Considerations

*   **Modularity:**
    *   The Invoice Generation Agent is designed as a distinct module (microservice or a well-encapsulated part of a monolith initially).
    *   Internal sub-modules (Core Engine, Template Management, Tax Engine) will be developed as logically separate components within the agent\'s codebase, promoting separation of concerns and maintainability. They can be refactored into separate microservices in the future if specific scaling needs arise for any of them.
*   **Multi-tenancy:**
    *   **Database:** All database tables related to invoices, templates, tax configurations, product catalogs, etc., will have a `tenant_id` column. The DAL will ensure that every query is scoped to the correct `tenant_id` based on the authenticated user\'s context. This provides strict data isolation.
    *   **Configuration:** Tenant-specific settings (e.g., default templates, tax rules, invoice numbering sequences) will be stored and managed per tenant.
    *   **Shared Resources:** If any resources are shared (e.g., certain types of system-level configurations), access control must be carefully managed.
*   **Scalability (Targeting millions of users/SMEs):
    *   **Stateless Service:** The Invoice Generation Agent service will be designed to be stateless. User session information, if any, should be stored externally (e.g., in a distributed cache like Redis or managed via tokens), allowing multiple instances of the agent to run behind a load balancer for horizontal scaling.
    *   **Database Optimization:**
        *   Comprehensive indexing on `tenant_id`, primary keys, foreign keys, and frequently queried fields (e.g., invoice dates, status, client IDs).
        *   Efficient query design to minimize load.
        *   Regular database maintenance and performance monitoring.
        *   Connection pooling will be implemented by the DAL/ORM.
        *   For very large data volumes anticipated with millions of SMEs, strategies like read replicas for reporting, and potential table partitioning (e.g., for the `invoices` table by `tenant_id` or date range) should be considered as the system grows.
    *   **Asynchronous Processing:** Operations that can be time-consuming and don\'t require an immediate synchronous response (e.g., AI OCR processing of large documents, bulk invoice imports, sending batch email notifications if added later) should be offloaded to a background job queue system (e.g., BullMQ with Redis, RabbitMQ). The API would return an immediate acknowledgment, and the user can be notified upon completion (e.g., via WebSockets or polling).
    *   **Caching:** Implement caching strategies (e.g., using Redis) for frequently accessed and relatively static data, such as tenant configurations, compiled invoice templates, or common product/service details. This reduces database load and improves response times.
    *   **Efficient Document Generation:** PDF generation can be resource-intensive. Optimize the process, and if it becomes a bottleneck, consider a dedicated microservice for document generation that can be scaled independently.

### 7.7. UI/UX Considerations (Alignment with `ui_ux_visual_guidelines.md`)

The architectural design of the backend APIs will be mindful of supporting the frontend in implementing the established UI/UX guidelines for visual cues and guided workflows.
*   APIs will be designed to provide clear and structured data, enabling the frontend to easily render step-by-step guidance, progress indicators, and highlight required inputs.
*   Error responses from the API will be detailed and constructive to help the frontend display user-friendly error messages and guidance for resolution.
*   For multi-step processes (e.g., AI-assisted invoice creation, complex configurations), APIs might be designed to handle partial submissions or save draft states, aligning with a guided workflow approach.




## 8. Conceptual Design for Terms and Conditions Agent (TCA) and Integration

This section outlines a conceptual high-level design for a future "Terms and Conditions Agent" (TCA) and its planned integration with the Invoice Generation Agent (IGA). The TCA is envisioned as a separate, specialized module.

### 8.1. Terms and Conditions Agent (TCA) - Overview and Purpose

*   **Purpose:** The TCA will be responsible for dynamically sourcing, selecting, and providing relevant terms and conditions (T&Cs) to be appended to invoices generated by the IGA.
*   **Goal:** To enhance invoice compliance, reduce manual effort in managing T&Cs, and tailor T&Cs based on specific agreements, client history, and company policies.
*   **Intelligence:** The TCA is expected to leverage NLP for document parsing and potentially ML/rules-based logic for contextual term selection.

### 8.2. TCA - Core Responsibilities (Conceptual)

1.  **Document Ingestion and Parsing:**
    *   Ingest various document types (e.g., PDFs, DOCX of contracts, Purchase Orders, Master Service Agreements) provided by the tenant.
    *   Utilize NLP and document understanding techniques to parse these documents, identify, and extract relevant clauses, obligations, and specific terms pertinent to invoicing (e.g., payment terms, late fee policies, dispute resolution, warranty clauses, service level agreements).
2.  **Terms Knowledge Base Management:**
    *   Maintain a structured, tenant-specific knowledge base of extracted T&Cs, standard legal clauses, and company-defined policies.
    *   Store metadata associated with each term (e.g., source document, applicability context, version).
3.  **Contextual Term Selection and Assembly:**
    *   Based on the context provided by the IGA (e.g., client ID, invoice details, associated contract references), intelligently select or assemble the most appropriate set of T&Cs.
    *   The selection logic may involve rules engines, keyword matching, or more advanced AI models considering factors like client history (if available through other agents or data points) and the nature of services/products on the invoice.
4.  **API for Term Provisioning:**
    *   Expose a secure internal API for the IGA (and potentially other agents) to request T&Cs for a given invoice context.

### 8.3. TCA - High-Level Components (Conceptual)

*   **Document Processing Service:** Handles document upload, pre-processing, OCR (if needed), and NLP-based parsing and extraction.
*   **Terms Knowledge Base:** A specialized database (e.g., document DB, graph DB, or relational with JSONB) to store and manage the structured terms and their relationships.
*   **Reasoning & Selection Engine:** The core logic unit that applies rules or models to select/generate the final T&Cs based on input context and the knowledge base.
*   **API Layer:** Provides endpoints for T&C requests and potentially for managing the knowledge base (e.g., uploading new documents for processing).

### 8.4. Integration with Invoice Generation Agent (IGA)

*   **Integration Point:** The IGA will interact with the TCA during the invoice finalization workflow, typically before an invoice is sent to the customer or a PDF is generated.
*   **Workflow:**
    1.  IGA prepares a draft invoice.
    2.  Before finalization/sending, IGA makes a request to the TCA, providing relevant contextual information.
    3.  TCA processes the request, selects/assembles the appropriate T&Cs, and returns them to the IGA.
    4.  IGA appends the received T&Cs to the invoice data before final rendering (e.g., in the PDF or email body).
*   **Data Exchange (Conceptual):**
    *   **Request from IGA to TCA:** Could include `tenant_id`, `client_id`, `invoice_id` (or draft invoice content like line items, total amount), references to any linked `contract_ids` or `agreement_ids`, `invoice_type`.
    *   **Response from TCA to IGA:** A structured representation of the terms and conditions (e.g., an array of strings, a formatted HTML/markdown block), and optionally, metadata about the T&Cs (e.g., source references).
*   **Communication Protocol:** An internal, synchronous REST API call is a likely first approach (e.g., IGA calls `POST /internal/api/v1/terms-agent/invoice-terms` with context). If T&C generation becomes highly complex and time-consuming, an asynchronous pattern could be explored.

### 8.5. Architectural Considerations for IGA to Support TCA Integration

*   The IGA\'s architecture (as defined in Section 7) should be flexible enough to accommodate this interaction. Specifically, the **Core Invoice Processing Engine** within the IGA\'s Service Layer will need a defined point in its workflow to call out to the TCA.
*   The IGA\'s data model for an invoice should have a dedicated field to store the T&Cs (potentially as rich text or markdown).
*   The IGA\'s template rendering mechanism must be able to incorporate these dynamically fetched T&Cs.

### 8.6. Multi-tenancy, Scalability, and Modularity for TCA

*   **Multi-tenancy:** The TCA must adhere to strict multi-tenancy. All tenant-specific documents, extracted terms, and configurations will be isolated by `tenant_id`.
*   **Scalability:** Document processing (NLP) can be resource-intensive. Asynchronous processing for document ingestion and analysis will be crucial. The T&C selection/reasoning engine and its knowledge base access must be optimized for performance. The TCA service itself should be designed to be stateless for horizontal scaling.
*   **Modularity:** The TCA will be developed as a separate, independent module/service, interacting with the IGA and other platform components via well-defined APIs. This aligns with the overall modular, agent-based architecture of the platform.

This conceptual outline for the TCA will be further refined when its development is prioritized. For the current phase focusing on the Invoice Generation Agent, its architecture will be designed with the necessary hooks and considerations for this future integration.
